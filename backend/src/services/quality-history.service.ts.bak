import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma.service';
import { SharedFolderService } from './shared-folder.service';
import { QualityHistory, InspectionBatch } from '@prisma/client';
import { CreateQualityHistoryDto } from '../dto/create-quality-history.dto';
import { UpdateQualityHistoryDto } from '../dto/update-quality-history.dto';

@Injectable()
export class QualityHistoryService {
  constructor(
    private prisma: PrismaService,
    private sharedFolderService: SharedFolderService
  ) {}

  async getQualityHistories(filters: { search?: string; limit?: number; offset?: number; }) {
    const where: any = {};
    if (filters.search) {
      where.orderNumber = { contains: filters.search };
    }
    const [qualityHistories, total] = await this.prisma.$transaction([
      this.prisma.qualityHistory.findMany({
        where,
        skip: filters.offset,
        take: filters.limit,
        orderBy: { createdAt: 'desc' },
        include: { excelOrders: true },
      }),
      this.prisma.qualityHistory.count({ where }),
    ]);
    return { qualityHistories, total, limit: filters.limit, offset: filters.offset };
  }

  async getQualityHistoryWithBatches(id: number): Promise<QualityHistory | null> {
    return this.prisma.qualityHistory.findUnique({
      where: { id },
      include: {
        inspectionBatches: {
          include: {
            incomingInspection: {
              include: {
                defects: {
                  include: {
                    defectType: true
                  }
                }
              }
            },
            processInspection: {
              include: {
                defects: {
                  include: {
                    defectType: true
                  }
                }
              }
            },
            shipmentInspection: {
              include: {
                rounds: {
                  include: {
                    workers: {
                      include: {
                        defects: {
                          include: {
                            defectType: true
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        excelOrders: true
      },
    });
  }

  async createQualityHistory(createQualityHistoryDto: { excelOrderIds: number[] }): Promise<QualityHistory> {
    // ExcelOrder 정보 조회
    const excelOrders = await this.prisma.excelOrder.findMany({
      where: { col0: { in: createQualityHistoryDto.excelOrderIds } },
    });
    // 중복 제거 함수
    function uniq(arr: any[]) {
      return Array.from(new Set(arr));
    }
    // 문자열 정규화 함수 (공백 제거)
    function normalize(str: string) {
      return (str ?? '').trim();
    }
    // 대표값 복수 조합(콤마 join, 중복 제거)
    const mainOrderNumber   = uniq(excelOrders.map(o => o.finalorderNumber).filter(Boolean)).join(', ');
    const mainProductName   = uniq(excelOrders.map(o => o.productName).filter(Boolean)).join(', ');
    const mainCustomerName  = uniq(excelOrders.map(o => o.customer).filter(Boolean)).join(', ');
    const mainPartName      = uniq(excelOrders.map(o => o.partName).filter(Boolean)).join(', ');
    const mainSpecification = uniq(excelOrders.map(o => o.specification).filter(Boolean)).join(', ');
    const mainManager       = uniq(excelOrders.map(o => normalize(o.manager ?? '')).filter(Boolean)).join(', ');
    // 품질이력 생성
    const qualityHistory = await this.prisma.qualityHistory.create({
      data: {
        mainOrderNumber,
        mainProductName,
        mainCustomerName,
        mainPartName,
        mainSpecification,
        mainManager,
      }
    });
    // ExcelOrder들의 qualityHistoryId 업데이트
    await this.prisma.excelOrder.updateMany({
      where: { col0: { in: createQualityHistoryDto.excelOrderIds } },
      data: { qualityHistoryId: qualityHistory.id },
    });
    return qualityHistory;
  }

  async updateQualityHistory(id: number, updateQualityHistoryDto: UpdateQualityHistoryDto): Promise<QualityHistory | null> {
    await this.prisma.qualityHistory.update({ where: { id }, data: updateQualityHistoryDto });
    return this.getQualityHistoryWithBatches(id);
  }

  async deleteQualityHistory(id: number): Promise<boolean> {
    const result = await this.prisma.qualityHistory.delete({ where: { id } });
    return !!result;
  }

  async createInspectionBatch(data: { qualityHistoryId: number; name?: string }): Promise<InspectionBatch> {
    // 1. 품질이력의 mainOrderNumber 조회
    const qualityHistory = await this.prisma.qualityHistory.findUnique({
      where: { id: data.qualityHistoryId },
    });
    const mainOrderNumber = qualityHistory?.mainOrderNumber || 'batch';
    // 2. 해당 품질이력의 기존 배치 개수 조회
    const batchCount = await this.prisma.inspectionBatch.count({
      where: { qualityHistoryId: data.qualityHistoryId },
    });
    // 3. name 자동 생성
    const name = `${mainOrderNumber} batch${batchCount + 1}`;
    return this.prisma.inspectionBatch.create({
      data: {
        ...data,
        name,
      },
    });
  }

  async deleteInspectionBatch(batchId: number): Promise<boolean> {
    try {
      // 1. 배치 정보 조회
      const batch = await this.prisma.inspectionBatch.findUnique({
        where: { id: batchId },
        include: {
          incomingInspection: true,
          processInspection: true,
          shipmentInspection: true,
        },
      });

      if (!batch) {
        throw new Error('Inspection batch not found');
      }

      // 2. 외래키 제약조건을 고려한 올바른 삭제 순서
      
      // 2-1. IncomingInspection 관련 데이터 삭제
      if (batch.incomingInspection) {
        // Defect 데이터 먼저 삭제
        await this.prisma.incomingInspectionDefect.deleteMany({
          where: { inspectionId: batch.incomingInspection.id }
        });
        
        // Attachment 데이터 조회 및 파일 삭제
        const incomingAttachments = await this.prisma.attachment.findMany({
          where: { incomingInspectionId: batch.incomingInspection.id }
        });
        
        // 이미지 파일 삭제
        for (const attachment of incomingAttachments) {
          try {
            // SharedFolderService에서 파일 경로를 자체적으로 조합
            await this.sharedFolderService.deleteImage(attachment.id.toString());
          } catch (error) {
            console.error(`이미지 파일 삭제 실패 (ID: ${attachment.id}):`, error);
            // 파일 삭제 실패해도 DB 삭제는 계속 진행
          }
        }
        
        // Attachment 데이터 삭제
        await this.prisma.attachment.deleteMany({
          where: { incomingInspectionId: batch.incomingInspection.id }
        });
        
        // IncomingInspection 삭제
        await this.prisma.incomingInspection.delete({
          where: { id: batch.incomingInspection.id }
        });
      }

      // 2-2. ProcessInspection 관련 데이터 삭제
      if (batch.processInspection) {
        // Defect 데이터 먼저 삭제
        await this.prisma.processInspectionDefect.deleteMany({
          where: { inspectionId: batch.processInspection.id }
        });
        
        // Round 데이터 삭제
        await this.prisma.processInspectionRound.deleteMany({
          where: { inspectionId: batch.processInspection.id }
        });
        
        // Attachment 데이터 조회 및 파일 삭제
        const processAttachments = await this.prisma.attachment.findMany({
          where: { processInspectionId: batch.processInspection.id }
        });
        
        // 이미지 파일 삭제
        for (const attachment of processAttachments) {
          try {
            // SharedFolderService에서 파일 경로를 자체적으로 조합
            await this.sharedFolderService.deleteImage(attachment.id.toString());
          } catch (error) {
            console.error(`이미지 파일 삭제 실패 (ID: ${attachment.id}):`, error);
            // 파일 삭제 실패해도 DB 삭제는 계속 진행
          }
        }
        
        // Attachment 데이터 삭제
        await this.prisma.attachment.deleteMany({
          where: { processInspectionId: batch.processInspection.id }
        });
        
        // ProcessInspection 삭제
        await this.prisma.processInspection.delete({
          where: { id: batch.processInspection.id }
        });
      }

      // 2-3. ShipmentInspection 관련 데이터 삭제
      if (batch.shipmentInspection) {
        // Round 데이터 조회
        const rounds = await this.prisma.shipmentInspectionRound.findMany({
          where: { inspectionId: batch.shipmentInspection.id },
          include: { workers: true }
        });

        // Worker별 Defect 데이터 삭제
        for (const round of rounds) {
          for (const worker of round.workers) {
            await this.prisma.shipmentInspectionDefect.deleteMany({
              where: { workerId: worker.id }
            });
          }
          // Worker 데이터 삭제
          await this.prisma.shipmentInspectionWorker.deleteMany({
            where: { roundId: round.id }
          });
        }

        // Round 데이터 삭제
        await this.prisma.shipmentInspectionRound.deleteMany({
          where: { inspectionId: batch.shipmentInspection.id }
        });

        // Attachment 데이터 조회 및 파일 삭제
        const shipmentAttachments = await this.prisma.attachment.findMany({
          where: { shipmentInspectionId: batch.shipmentInspection.id }
        });
        
        // 이미지 파일 삭제
        for (const attachment of shipmentAttachments) {
          try {
            // SharedFolderService에서 파일 경로를 자체적으로 조합
            await this.sharedFolderService.deleteImage(attachment.id.toString());
          } catch (error) {
            console.error(`이미지 파일 삭제 실패 (ID: ${attachment.id}):`, error);
            // 파일 삭제 실패해도 DB 삭제는 계속 진행
          }
        }
        
        // Attachment 데이터 삭제
        await this.prisma.attachment.deleteMany({
          where: { shipmentInspectionId: batch.shipmentInspection.id }
        });

        // ShipmentInspection 삭제
        await this.prisma.shipmentInspection.delete({
          where: { id: batch.shipmentInspection.id }
        });
      }

      // 3. 배치 삭제
      const result = await this.prisma.inspectionBatch.delete({ where: { id: batchId } });
      return !!result;
    } catch (error) {
      console.error('deleteInspectionBatch error:', error);
      throw error; // 에러를 다시 던져서 컨트롤러에서 처리하도록 함
    }
  }

  // 개별 검사 삭제 메서드들
  async deleteIncomingInspection(batchId: number): Promise<boolean> {
    try {
      const batch = await this.prisma.inspectionBatch.findUnique({
        where: { id: batchId },
        include: { incomingInspection: true },
      });

      if (!batch || !batch.incomingInspection) {
        throw new Error('Incoming inspection not found');
      }

      // Defect 데이터 먼저 삭제
      await this.prisma.incomingInspectionDefect.deleteMany({
        where: { inspectionId: batch.incomingInspection.id }
      });
      
      // Attachment 데이터 조회 및 파일 삭제
      const attachments = await this.prisma.attachment.findMany({
        where: { incomingInspectionId: batch.incomingInspection.id }
      });
      
      // 이미지 파일 삭제
      for (const attachment of attachments) {
        try {
          // SharedFolderService에서 파일 경로를 자체적으로 조합
          await this.sharedFolderService.deleteImage(attachment.id.toString());
        } catch (error) {
          console.error(`이미지 파일 삭제 실패 (ID: ${attachment.id}):`, error);
          // 파일 삭제 실패해도 DB 삭제는 계속 진행
        }
      }
      
      // Attachment 데이터 삭제
      await this.prisma.attachment.deleteMany({
        where: { incomingInspectionId: batch.incomingInspection.id }
      });
      
      // IncomingInspection 삭제
      await this.prisma.incomingInspection.delete({
        where: { id: batch.incomingInspection.id }
      });

      return true;
    } catch (error) {
      console.error('deleteIncomingInspection error:', error);
      throw error;
    }
  }

  async deleteProcessInspection(batchId: number): Promise<boolean> {
    try {
      const batch = await this.prisma.inspectionBatch.findUnique({
        where: { id: batchId },
        include: { processInspection: true },
      });

      if (!batch || !batch.processInspection) {
        throw new Error('Process inspection not found');
      }

      // Defect 데이터 먼저 삭제
      await this.prisma.processInspectionDefect.deleteMany({
        where: { inspectionId: batch.processInspection.id }
      });
      
      // Round 데이터 삭제
      await this.prisma.processInspectionRound.deleteMany({
        where: { inspectionId: batch.processInspection.id }
      });
      
      // Attachment 데이터 조회 및 파일 삭제
      const attachments = await this.prisma.attachment.findMany({
        where: { processInspectionId: batch.processInspection.id }
      });
      
      // 이미지 파일 삭제
      for (const attachment of attachments) {
        try {
          // SharedFolderService에서 파일 경로를 자체적으로 조합
          await this.sharedFolderService.deleteImage(attachment.id.toString());
        } catch (error) {
          console.error(`이미지 파일 삭제 실패 (ID: ${attachment.id}):`, error);
          // 파일 삭제 실패해도 DB 삭제는 계속 진행
        }
      }
      
      // Attachment 데이터 삭제
      await this.prisma.attachment.deleteMany({
        where: { processInspectionId: batch.processInspection.id }
      });
      
      // ProcessInspection 삭제
      await this.prisma.processInspection.delete({
        where: { id: batch.processInspection.id }
      });

      return true;
    } catch (error) {
      console.error('deleteProcessInspection error:', error);
      throw error;
    }
  }

  async deleteShipmentInspection(batchId: number): Promise<boolean> {
    try {
      const batch = await this.prisma.inspectionBatch.findUnique({
        where: { id: batchId },
        include: { shipmentInspection: true },
      });

      if (!batch || !batch.shipmentInspection) {
        throw new Error('Shipment inspection not found');
      }

      // Round 데이터 조회
      const rounds = await this.prisma.shipmentInspectionRound.findMany({
        where: { inspectionId: batch.shipmentInspection.id },
        include: { workers: true }
      });

      // Worker별 Defect 데이터 삭제
      for (const round of rounds) {
        for (const worker of round.workers) {
          await this.prisma.shipmentInspectionDefect.deleteMany({
            where: { workerId: worker.id }
          });
        }
        // Worker 데이터 삭제
        await this.prisma.shipmentInspectionWorker.deleteMany({
          where: { roundId: round.id }
        });
      }

      // Round 데이터 삭제
      await this.prisma.shipmentInspectionRound.deleteMany({
        where: { inspectionId: batch.shipmentInspection.id }
      });

      // Attachment 데이터 조회 및 파일 삭제
      const attachments = await this.prisma.attachment.findMany({
        where: { shipmentInspectionId: batch.shipmentInspection.id }
      });
      
      // 이미지 파일 삭제
      for (const attachment of attachments) {
        try {
          // SharedFolderService에서 파일 경로를 자체적으로 조합
          await this.sharedFolderService.deleteImage(attachment.id.toString());
        } catch (error) {
          console.error(`이미지 파일 삭제 실패 (ID: ${attachment.id}):`, error);
          // 파일 삭제 실패해도 DB 삭제는 계속 진행
        }
      }
      
      // Attachment 데이터 삭제
      await this.prisma.attachment.deleteMany({
        where: { shipmentInspectionId: batch.shipmentInspection.id }
      });

      // ShipmentInspection 삭제
      await this.prisma.shipmentInspection.delete({
        where: { id: batch.shipmentInspection.id }
      });

      return true;
    } catch (error) {
      console.error('deleteShipmentInspection error:', error);
      throw error;
    }
  }

  async bulkCreateFromExcel(rows: any[]): Promise<{ success: number; failed: number; results: any[] }> {
    let success = 0;
    let failed = 0;
    const results = [];
    for (const [i, row] of rows.entries()) {
      // 중복 체크: 기존 orderNumber 등 필드 체크 제거
      // 항상 새 이력 생성
      try {
        await this.prisma.qualityHistory.create({ data: {} });
        success++;
        results.push({ row: i + 2, status: 'success', data: row });
      } catch (err) {
        failed++;
        results.push({ row: i + 2, status: 'failed', reason: err.message, data: row });
      }
    }
    return { success, failed, results };
  }

  async getQualityHistoryByOrderNumber(orderNumber: string) {
    // 기존: 품질 이력 테이블에서 조회
    // return this.prisma.qualityHistory.findFirst({ where: { orderNumber } });
    // 수정: 엑셀 업로드 테이블에서 조회
    return this.prisma.excelOrder.findFirst({ where: { finalorderNumber: orderNumber } });
  }

  async getInspectionBatchById(id: number) {
    return this.prisma.inspectionBatch.findUnique({
      where: { id },
      include: {
        incomingInspection: true,
        processInspection: true,
        shipmentInspection: true,
        qualityHistory: true,
      },
    });
  }
}